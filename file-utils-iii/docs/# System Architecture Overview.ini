# System Architecture Overview

## 🏗️ High-Level Architecture

The Quantum Resonant Search Engine is built as a modular system with three primary operating modes:

1. **Local Filesystem Search** - High-speed indexing and search of local files
2. **Web Crawler Mode** - Large-scale web content harvesting and indexing  
3. **Web Server Mode** - HTTP API and web interface for search

```
┌─────────────────────────────────────────────────────────────┐
│                     User Interface Layer                    │
├─────────────────┬───────────────────┬─────────────────────┤
│   CLI Interface │   Web Interface   │    REST API         │
│                 │   (HTML/CSS/JS)   │   (/api/search)     │
└─────────────────┼───────────────────┼─────────────────────┘
                  │                   │
┌─────────────────▼───────────────────▼─────────────────────┐
│                  Search Engine Core                      │
├─────────────────────────────────────────────────────────┤
│  • Prime Vector Encoding    • Quantum-Inspired Scoring  │
│  • Entropy Calculations     • Persistence Theory        │
│  • Biorthogonal Matching    • Adaptive Learning         │
└─────────────────┬───────────────────┬─────────────────────┘
                  │                   │
┌─────────────────▼─────────────────┬─▼─────────────────────┐
│      Filesystem Indexer           │    Web Crawler        │
├───────────────────────────────────┼───────────────────────┤
│ • Real-time file monitoring      │ • Robots.txt support  │
│ • Content type detection         │ • Rate limiting        │
│ • Metadata extraction            │ • Link following       │
│ • Fuzzy filename matching        │ • Politeness features │
└───────────────────────────────────┼───────────────────────┘
                  │                   │
┌─────────────────▼───────────────────▼─────────────────────┐
│                   Storage Layer                          │
├─────────────────────────────────────────────────────────┤
│  • SQLite Database     • Compressed Indices             │
│  • Index Checkpoints   • Real-time Updates              │
│  • File Watching       • Export/Import Tools            │
└─────────────────────────────────────────────────────────┘
```

## 🧠 Core Components

### 1. Tokenizer (`tokenizer.rs`)
- **Prime Number Mapping**: Each unique token gets assigned a prime number
- **Vocabulary Management**: Persistent token-to-prime mappings
- **Text Processing**: Regex-based word extraction and normalization

```rust
PrimeTokenizer {
    token_to_prime: HashMap<String, u64>,
    prime_to_token: HashMap<u64, String>,
    current_prime: u64,
}
```

### 2. Prime Hilbert Space (`prime_hilbert.rs`)
- **Vector Construction**: Builds normalized frequency vectors from prime sequences
- **Sparse Operations**: Efficient dot products over sparse prime vectors
- **Biorthogonal Representation**: Left/right vector pairs for non-Hermitian dynamics

```rust
type PrimeVector = HashMap<u64, f64>;

struct BiorthogonalVector {
    left: PrimeVector,
    right: PrimeVector,
}
```

### 3. Entropy Engine (`entropy.rs`)
- **Shannon Entropy**: Measures informational uncertainty
- **Persistence Metrics**: Thermodynamic stability calculations
- **Non-Hermitian Decay**: Quantum-inspired information degradation
- **Reversibility**: Mutual information retention across transformations

### 4. Quantum Types (`quantum_types.rs`)
- **Complex Matrices**: Support for non-Hermitian operators
- **Lindblad Evolution**: Quantum master equation implementation
- **Density Matrices**: Quantum state representations
- **Trace Operations**: Matrix trace calculations for normalization

### 5. Search Engine Core (`engine.rs`)
- **Document Indexing**: Converts documents to prime vectors
- **Scoring Pipeline**: Combines resonance, quantum, and persistence scores
- **Adaptive Learning**: Quantum jump mechanisms for relevance evolution
- **Result Ranking**: Multi-dimensional scoring with configurable weights

## 🗂️ Data Flow Architecture

### Indexing Pipeline

```
Raw Document → Tokenization → Prime Encoding → Vector Building → Entropy Calculation
     │              │              │               │                │
     ▼              ▼              ▼               ▼                ▼
File Content → Word Tokens → Prime Sequence → Sparse Vector → Document Record
     │              │              │               │                │
     ▼              ▼              ▼               ▼                ▼
Metadata     → Normalization → Vocabulary → Biorthogonal → Index Storage
```

### Search Pipeline

```
Query Input → Tokenization → Vector Building → Similarity Scoring → Result Ranking
     │              │              │               │                │
     ▼              ▼              ▼               ▼                ▼
"entropy    → ["entropy",    → [2, 3, 5]    → Resonance Score → Top Results
 collapse      "collapse"]                    Quantum Score      Snippets
 meaning"                                     Persistence Score   Metadata
```

### Scoring Components

```
Final Score = α·Resonance + β·Quantum + γ·Persistence - δ·ΔEntropy

Where:
• Resonance = dot_product(query_vector, doc_vector)
• Quantum = complex_resonance + biorthogonal_score  
• Persistence = exp[-α(1-η)(Q/T)]
• ΔEntropy = |entropy(query) - entropy(doc)|
```

## 🕸️ Web Architecture

### Server Components

```
┌─────────────────────────────────────────────────────────────┐
│                    Axum Web Server                          │
├─────────────────────────────────────────────────────────────┤
│  Router → Handlers → Services → Storage                    │
└─────────────────────────────────────────────────────────────┘

HTTP Request → Route Matching → Handler Function → Search API → Database
     │              │               │                │            │
     ▼              ▼               ▼                ▼            ▼
GET /api/search → /api/* routes → search_handler → engine.search() → SQLite
POST /api/index → Static files  → index_handler → engine.add()    → Results
```

### Client-Server Communication

```javascript
// Frontend (app.js)
fetch('/api/search', {
    method: 'GET',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
        query: "quantum mechanics",
        quantum_scoring: true,
        persistence_scoring: true,
        max_results: 10
    })
})

// Backend Response
{
    "query": "quantum mechanics",
    "total_results": 42,
    "search_time_ms": 23,
    "results": [
        {
            "title": "Introduction to Quantum Physics",
            "url": "https://example.com/quantum",
            "resonance_score": 0.8432,
            "quantum_score": 0.7821,
            "persistence_score": 0.6543,
            "combined_score": 0.7456,
            "snippet": "Quantum mechanics is the fundamental theory..."
        }
    ]
}
```

## 🗄️ Storage Architecture

### Database Schema (SQLite)

```sql
-- Core document storage
CREATE TABLE documents (
    id INTEGER PRIMARY KEY,
    url TEXT UNIQUE NOT NULL,
    title TEXT NOT NULL,
    content_hash TEXT,
    created_at INTEGER,
    modified_at INTEGER,
    file_size INTEGER,
    content_type TEXT
);

-- Compressed document content
CREATE TABLE document_content (
    document_id INTEGER PRIMARY KEY,
    compressed_text BLOB,
    entropy REAL,
    reversibility REAL,
    buffering_capacity REAL,
    FOREIGN KEY (document_id) REFERENCES documents(id)
);

-- Prime vector storage
CREATE TABLE document_vectors (
    document_id INTEGER,
    prime_number INTEGER,
    frequency REAL,
    PRIMARY KEY (document_id, prime_number),
    FOREIGN KEY (document_id) REFERENCES documents(id)
);

-- Search performance indices
CREATE INDEX idx_documents_url ON documents(url);
CREATE INDEX idx_documents_modified ON documents(modified_at);
CREATE INDEX idx_vectors_prime ON document_vectors(prime_number);
```

### Index File Structure

```
data/
├── quantum_fs_index.db          # Local filesystem index
├── search_db.sqlite             # Web search database  
├── checkpoints/                 # Recovery checkpoints
│   ├── latest.checkpoint        # Most recent state
│   └── backup_*.checkpoint      # Timestamped backups
└── cache/                       # Temporary storage
    ├── prime_mappings.json      # Token-to-prime cache
    └── vector_cache/            # Pre-computed vectors
```

## ⚡ Performance Architecture

### Memory Management

```rust
// Compressed document storage
struct IndexedDocument {
    title: String,
    compressed_content: Option<Vec<u8>>,  // Gzip compressed
    vector: PrimeVector,                  // Sparse representation
    metadata: DocumentMetadata,
}

// On-demand decompression
impl IndexedDocument {
    fn get_content(&mut self) -> &str {
        if self.text.is_empty() && self.compressed_content.is_some() {
            // Decompress on access
            self.text = decompress(&self.compressed_content);
        }
        &self.text
    }
}
```

### Concurrent Processing

```rust
// Multi-threaded indexing
tokio::spawn(async move {
    let semaphore = Arc::new(Semaphore::new(num_workers));
    
    stream::iter(files)
        .for_each_concurrent(num_workers, |file| {
            let permit = semaphore.clone().acquire_owned();
            async move {
                let _permit = permit.await;
                process_file(file).await;
            }
        })
        .await;
});
```

### Caching Strategy

```
L1: In-Memory Vector Cache (LRU, 1000 documents)
L2: Compressed Document Cache (5000 documents)  
L3: Database Storage (unlimited, persistent)

Search Query → L1 Check → L2 Check → L3 Database → Compute Vector
                ↓           ↓           ↓              ↓
              Hit: 1ms    Hit: 5ms    Hit: 20ms    Miss: 100ms
```

## 🔄 Real-Time Updates

### File Watching Architecture

```rust
FileWatcher → Event Filter → Update Queue → Index Updater
     │             │             │              │
     ▼             ▼             ▼              ▼
File Change → Relevant? → Batch Updates → Vector Recompute
Create/Modify   Yes/No     Every 100ms     Incremental Only
Delete/Move
```

### Event Processing

```rust
enum FileEvent {
    Created(PathBuf),
    Modified(PathBuf),
    Deleted(PathBuf),
    Renamed { from: PathBuf, to: PathBuf },
}

// Batch processing for efficiency
let mut update_batch = Vec::new();
let mut last_update = Instant::now();

if events.len() > 100 || last_update.elapsed() > Duration::from_millis(500) {
    process_batch(update_batch).await;
    update_batch.clear();
    last_update = Instant::now();
}
```

## 🧪 Quantum Simulation Architecture

### HQE (Holographic Quantum Encoder)

```rust
// Quantum state simulation
struct QuantumState {
    amplitudes: Vec<Complex<f64>>,
    phases: Vec<f64>,
    entropy: f64,
    coherence: f64,
}

// Evolution simulation
impl QuantumState {
    fn evolve(&mut self, hamiltonian: &Matrix<Complex<f64>>, dt: f64) {
        // Lindblad evolution with entropy feedback
        let unitary_part = hamiltonian * self.density_matrix();
        let dissipative_part = self.calculate_decoherence();
        
        self.apply_evolution(unitary_part + dissipative_part, dt);
        self.normalize();
    }
}
```

### Consciousness Correlation

```rust
// EEG coherence integration (experimental)
struct ConsciousnessDetector {
    eeg_buffer: VecDeque<f64>,
    coherence_threshold: f64,
    alpha_band_filter: BandpassFilter,
}

impl ConsciousnessDetector {
    fn measure_coherence(&self, search_results: &[SearchResult]) -> f64 {
        let eeg_coherence = self.calculate_alpha_coherence();
        let semantic_coherence = self.calculate_result_coherence(search_results);
        
        // Cross-correlation between brain state and search relevance
        cross_correlate(eeg_coherence, semantic_coherence)
    }
}
```

## 🔧 Configuration Architecture

### Hierarchical Configuration

```toml
# config.toml - Main configuration
[engine]
entropy_weight = 0.1
fragility = 0.2
trend_decay = 0.05

[quantum]
enable_scoring = true
enable_persistence = true
complex_resonance = true

[filesystem]
max_file_size = 10485760  # 10MB
excluded_patterns = [".git/", "node_modules/", "target/"]
file_types = ["txt", "md", "rs", "py", "js", "json", "yaml"]

[crawler]
max_pages = 25000
max_depth = 3
workers = 10
politeness_delay = 100  # ms
respect_robots_txt = true

[server]
port = 8080
workers = 4
rate_limit = 100  # requests per minute
```

### Runtime Configuration

```rust
// Dynamic parameter tuning
pub struct SearchConfig {
    pub quantum_enabled: bool,
    pub persistence_enabled: bool,
    pub entropy_weight: f64,
    pub fragility: f64,
    pub max_results: usize,
}

// Configuration hot-reloading
impl SearchConfig {
    pub fn reload(&mut self, path: &Path) -> Result<(), ConfigError> {
        let new_config = toml::from_str(&fs::read_to_string(path)?)?;
        *self = new_config;
        Ok(())
    }
}
```

## 📊 Monitoring & Observability

### Metrics Collection

```rust
struct EngineMetrics {
    search_count: Counter,
    search_latency: Histogram,
    index_size: Gauge,
    memory_usage: Gauge,
    quantum_score_distribution: Histogram,
    persistence_score_distribution: Histogram,
}

// Performance monitoring
impl ResonantEngine {
    pub fn search_with_metrics(&mut self, query: &str) -> Vec<SearchResult> {
        let start = Instant::now();
        let results = self.search(query, 10);
        
        self.metrics.search_count.inc();
        self.metrics.search_latency.observe(start.elapsed().as_millis() as f64);
        
        results
    }
}
```

### Health Checks

```rust
#[derive(Serialize)]
pub struct HealthStatus {
    pub status: String,
    pub index_size: usize,
    pub memory_usage_mb: f64,
    pub uptime_seconds: u64,
    pub quantum_enabled: bool,
    pub persistence_enabled: bool,
}

// GET /api/health
pub async fn health_check(engine: Arc<Mutex<ResonantEngine>>) -> Json<HealthStatus> {
    let engine = engine.lock().unwrap();
    Json(HealthStatus {
        status: "healthy".to_string(),
        index_size: engine.len(),
        memory_usage_mb: get_memory_usage(),
        uptime_seconds: get_uptime(),
        quantum_enabled: engine.quantum_enabled(),
        persistence_enabled: engine.persistence_enabled(),
    })
}
```

This architecture enables the quantum resonant search engine to operate efficiently across multiple modes while maintaining the mathematical rigor of the underlying quantum-inspired algorithms.

---

*For implementation details, see the individual module documentation in the source code.*