# System Architecture Overview

## ğŸ—ï¸ High-Level Architecture

The Quantum Resonant Search Engine is built as a modular system with three primary operating modes:

1. **Local Filesystem Search** - High-speed indexing and search of local files
2. **Web Crawler Mode** - Large-scale web content harvesting and indexing  
3. **Web Server Mode** - HTTP API and web interface for search

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     User Interface Layer                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   CLI Interface â”‚   Web Interface   â”‚    REST API         â”‚
â”‚                 â”‚   (HTML/CSS/JS)   â”‚   (/api/search)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚                   â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Search Engine Core                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â€¢ Prime Vector Encoding    â€¢ Quantum-Inspired Scoring  â”‚
â”‚  â€¢ Entropy Calculations     â€¢ Persistence Theory        â”‚
â”‚  â€¢ Biorthogonal Matching    â€¢ Adaptive Learning         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚                   â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      Filesystem Indexer           â”‚    Web Crawler        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â€¢ Real-time file monitoring      â”‚ â€¢ Robots.txt support  â”‚
â”‚ â€¢ Content type detection         â”‚ â€¢ Rate limiting        â”‚
â”‚ â€¢ Metadata extraction            â”‚ â€¢ Link following       â”‚
â”‚ â€¢ Fuzzy filename matching        â”‚ â€¢ Politeness features â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚                   â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Storage Layer                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â€¢ SQLite Database     â€¢ Compressed Indices             â”‚
â”‚  â€¢ Index Checkpoints   â€¢ Real-time Updates              â”‚
â”‚  â€¢ File Watching       â€¢ Export/Import Tools            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ§  Core Components

### 1. Tokenizer (`tokenizer.rs`)
- **Prime Number Mapping**: Each unique token gets assigned a prime number
- **Vocabulary Management**: Persistent token-to-prime mappings
- **Text Processing**: Regex-based word extraction and normalization

```rust
PrimeTokenizer {
    token_to_prime: HashMap<String, u64>,
    prime_to_token: HashMap<u64, String>,
    current_prime: u64,
}
```

### 2. Prime Hilbert Space (`prime_hilbert.rs`)
- **Vector Construction**: Builds normalized frequency vectors from prime sequences
- **Sparse Operations**: Efficient dot products over sparse prime vectors
- **Biorthogonal Representation**: Left/right vector pairs for non-Hermitian dynamics

```rust
type PrimeVector = HashMap<u64, f64>;

struct BiorthogonalVector {
    left: PrimeVector,
    right: PrimeVector,
}
```

### 3. Entropy Engine (`entropy.rs`)
- **Shannon Entropy**: Measures informational uncertainty
- **Persistence Metrics**: Thermodynamic stability calculations
- **Non-Hermitian Decay**: Quantum-inspired information degradation
- **Reversibility**: Mutual information retention across transformations

### 4. Quantum Types (`quantum_types.rs`)
- **Complex Matrices**: Support for non-Hermitian operators
- **Lindblad Evolution**: Quantum master equation implementation
- **Density Matrices**: Quantum state representations
- **Trace Operations**: Matrix trace calculations for normalization

### 5. Search Engine Core (`engine.rs`)
- **Document Indexing**: Converts documents to prime vectors
- **Scoring Pipeline**: Combines resonance, quantum, and persistence scores
- **Adaptive Learning**: Quantum jump mechanisms for relevance evolution
- **Result Ranking**: Multi-dimensional scoring with configurable weights

## ğŸ—‚ï¸ Data Flow Architecture

### Indexing Pipeline

```
Raw Document â†’ Tokenization â†’ Prime Encoding â†’ Vector Building â†’ Entropy Calculation
     â”‚              â”‚              â”‚               â”‚                â”‚
     â–¼              â–¼              â–¼               â–¼                â–¼
File Content â†’ Word Tokens â†’ Prime Sequence â†’ Sparse Vector â†’ Document Record
     â”‚              â”‚              â”‚               â”‚                â”‚
     â–¼              â–¼              â–¼               â–¼                â–¼
Metadata     â†’ Normalization â†’ Vocabulary â†’ Biorthogonal â†’ Index Storage
```

### Search Pipeline

```
Query Input â†’ Tokenization â†’ Vector Building â†’ Similarity Scoring â†’ Result Ranking
     â”‚              â”‚              â”‚               â”‚                â”‚
     â–¼              â–¼              â–¼               â–¼                â–¼
"entropy    â†’ ["entropy",    â†’ [2, 3, 5]    â†’ Resonance Score â†’ Top Results
 collapse      "collapse"]                    Quantum Score      Snippets
 meaning"                                     Persistence Score   Metadata
```

### Scoring Components

```
Final Score = Î±Â·Resonance + Î²Â·Quantum + Î³Â·Persistence - Î´Â·Î”Entropy

Where:
â€¢ Resonance = dot_product(query_vector, doc_vector)
â€¢ Quantum = complex_resonance + biorthogonal_score  
â€¢ Persistence = exp[-Î±(1-Î·)(Q/T)]
â€¢ Î”Entropy = |entropy(query) - entropy(doc)|
```

## ğŸ•¸ï¸ Web Architecture

### Server Components

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Axum Web Server                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Router â†’ Handlers â†’ Services â†’ Storage                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

HTTP Request â†’ Route Matching â†’ Handler Function â†’ Search API â†’ Database
     â”‚              â”‚               â”‚                â”‚            â”‚
     â–¼              â–¼               â–¼                â–¼            â–¼
GET /api/search â†’ /api/* routes â†’ search_handler â†’ engine.search() â†’ SQLite
POST /api/index â†’ Static files  â†’ index_handler â†’ engine.add()    â†’ Results
```

### Client-Server Communication

```javascript
// Frontend (app.js)
fetch('/api/search', {
    method: 'GET',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
        query: "quantum mechanics",
        quantum_scoring: true,
        persistence_scoring: true,
        max_results: 10
    })
})

// Backend Response
{
    "query": "quantum mechanics",
    "total_results": 42,
    "search_time_ms": 23,
    "results": [
        {
            "title": "Introduction to Quantum Physics",
            "url": "https://example.com/quantum",
            "resonance_score": 0.8432,
            "quantum_score": 0.7821,
            "persistence_score": 0.6543,
            "combined_score": 0.7456,
            "snippet": "Quantum mechanics is the fundamental theory..."
        }
    ]
}
```

## ğŸ—„ï¸ Storage Architecture

### Database Schema (SQLite)

```sql
-- Core document storage
CREATE TABLE documents (
    id INTEGER PRIMARY KEY,
    url TEXT UNIQUE NOT NULL,
    title TEXT NOT NULL,
    content_hash TEXT,
    created_at INTEGER,
    modified_at INTEGER,
    file_size INTEGER,
    content_type TEXT
);

-- Compressed document content
CREATE TABLE document_content (
    document_id INTEGER PRIMARY KEY,
    compressed_text BLOB,
    entropy REAL,
    reversibility REAL,
    buffering_capacity REAL,
    FOREIGN KEY (document_id) REFERENCES documents(id)
);

-- Prime vector storage
CREATE TABLE document_vectors (
    document_id INTEGER,
    prime_number INTEGER,
    frequency REAL,
    PRIMARY KEY (document_id, prime_number),
    FOREIGN KEY (document_id) REFERENCES documents(id)
);

-- Search performance indices
CREATE INDEX idx_documents_url ON documents(url);
CREATE INDEX idx_documents_modified ON documents(modified_at);
CREATE INDEX idx_vectors_prime ON document_vectors(prime_number);
```

### Index File Structure

```
data/
â”œâ”€â”€ quantum_fs_index.db          # Local filesystem index
â”œâ”€â”€ search_db.sqlite             # Web search database  
â”œâ”€â”€ checkpoints/                 # Recovery checkpoints
â”‚   â”œâ”€â”€ latest.checkpoint        # Most recent state
â”‚   â””â”€â”€ backup_*.checkpoint      # Timestamped backups
â””â”€â”€ cache/                       # Temporary storage
    â”œâ”€â”€ prime_mappings.json      # Token-to-prime cache
    â””â”€â”€ vector_cache/            # Pre-computed vectors
```

## âš¡ Performance Architecture

### Memory Management

```rust
// Compressed document storage
struct IndexedDocument {
    title: String,
    compressed_content: Option<Vec<u8>>,  // Gzip compressed
    vector: PrimeVector,                  // Sparse representation
    metadata: DocumentMetadata,
}

// On-demand decompression
impl IndexedDocument {
    fn get_content(&mut self) -> &str {
        if self.text.is_empty() && self.compressed_content.is_some() {
            // Decompress on access
            self.text = decompress(&self.compressed_content);
        }
        &self.text
    }
}
```

### Concurrent Processing

```rust
// Multi-threaded indexing
tokio::spawn(async move {
    let semaphore = Arc::new(Semaphore::new(num_workers));
    
    stream::iter(files)
        .for_each_concurrent(num_workers, |file| {
            let permit = semaphore.clone().acquire_owned();
            async move {
                let _permit = permit.await;
                process_file(file).await;
            }
        })
        .await;
});
```

### Caching Strategy

```
L1: In-Memory Vector Cache (LRU, 1000 documents)
L2: Compressed Document Cache (5000 documents)  
L3: Database Storage (unlimited, persistent)

Search Query â†’ L1 Check â†’ L2 Check â†’ L3 Database â†’ Compute Vector
                â†“           â†“           â†“              â†“
              Hit: 1ms    Hit: 5ms    Hit: 20ms    Miss: 100ms
```

## ğŸ”„ Real-Time Updates

### File Watching Architecture

```rust
FileWatcher â†’ Event Filter â†’ Update Queue â†’ Index Updater
     â”‚             â”‚             â”‚              â”‚
     â–¼             â–¼             â–¼              â–¼
File Change â†’ Relevant? â†’ Batch Updates â†’ Vector Recompute
Create/Modify   Yes/No     Every 100ms     Incremental Only
Delete/Move
```

### Event Processing

```rust
enum FileEvent {
    Created(PathBuf),
    Modified(PathBuf),
    Deleted(PathBuf),
    Renamed { from: PathBuf, to: PathBuf },
}

// Batch processing for efficiency
let mut update_batch = Vec::new();
let mut last_update = Instant::now();

if events.len() > 100 || last_update.elapsed() > Duration::from_millis(500) {
    process_batch(update_batch).await;
    update_batch.clear();
    last_update = Instant::now();
}
```

## ğŸ§ª Quantum Simulation Architecture

### HQE (Holographic Quantum Encoder)

```rust
// Quantum state simulation
struct QuantumState {
    amplitudes: Vec<Complex<f64>>,
    phases: Vec<f64>,
    entropy: f64,
    coherence: f64,
}

// Evolution simulation
impl QuantumState {
    fn evolve(&mut self, hamiltonian: &Matrix<Complex<f64>>, dt: f64) {
        // Lindblad evolution with entropy feedback
        let unitary_part = hamiltonian * self.density_matrix();
        let dissipative_part = self.calculate_decoherence();
        
        self.apply_evolution(unitary_part + dissipative_part, dt);
        self.normalize();
    }
}
```

### Consciousness Correlation

```rust
// EEG coherence integration (experimental)
struct ConsciousnessDetector {
    eeg_buffer: VecDeque<f64>,
    coherence_threshold: f64,
    alpha_band_filter: BandpassFilter,
}

impl ConsciousnessDetector {
    fn measure_coherence(&self, search_results: &[SearchResult]) -> f64 {
        let eeg_coherence = self.calculate_alpha_coherence();
        let semantic_coherence = self.calculate_result_coherence(search_results);
        
        // Cross-correlation between brain state and search relevance
        cross_correlate(eeg_coherence, semantic_coherence)
    }
}
```

## ğŸ”§ Configuration Architecture

### Hierarchical Configuration

```toml
# config.toml - Main configuration
[engine]
entropy_weight = 0.1
fragility = 0.2
trend_decay = 0.05

[quantum]
enable_scoring = true
enable_persistence = true
complex_resonance = true

[filesystem]
max_file_size = 10485760  # 10MB
excluded_patterns = [".git/", "node_modules/", "target/"]
file_types = ["txt", "md", "rs", "py", "js", "json", "yaml"]

[crawler]
max_pages = 25000
max_depth = 3
workers = 10
politeness_delay = 100  # ms
respect_robots_txt = true

[server]
port = 8080
workers = 4
rate_limit = 100  # requests per minute
```

### Runtime Configuration

```rust
// Dynamic parameter tuning
pub struct SearchConfig {
    pub quantum_enabled: bool,
    pub persistence_enabled: bool,
    pub entropy_weight: f64,
    pub fragility: f64,
    pub max_results: usize,
}

// Configuration hot-reloading
impl SearchConfig {
    pub fn reload(&mut self, path: &Path) -> Result<(), ConfigError> {
        let new_config = toml::from_str(&fs::read_to_string(path)?)?;
        *self = new_config;
        Ok(())
    }
}
```

## ğŸ“Š Monitoring & Observability

### Metrics Collection

```rust
struct EngineMetrics {
    search_count: Counter,
    search_latency: Histogram,
    index_size: Gauge,
    memory_usage: Gauge,
    quantum_score_distribution: Histogram,
    persistence_score_distribution: Histogram,
}

// Performance monitoring
impl ResonantEngine {
    pub fn search_with_metrics(&mut self, query: &str) -> Vec<SearchResult> {
        let start = Instant::now();
        let results = self.search(query, 10);
        
        self.metrics.search_count.inc();
        self.metrics.search_latency.observe(start.elapsed().as_millis() as f64);
        
        results
    }
}
```

### Health Checks

```rust
#[derive(Serialize)]
pub struct HealthStatus {
    pub status: String,
    pub index_size: usize,
    pub memory_usage_mb: f64,
    pub uptime_seconds: u64,
    pub quantum_enabled: bool,
    pub persistence_enabled: bool,
}

// GET /api/health
pub async fn health_check(engine: Arc<Mutex<ResonantEngine>>) -> Json<HealthStatus> {
    let engine = engine.lock().unwrap();
    Json(HealthStatus {
        status: "healthy".to_string(),
        index_size: engine.len(),
        memory_usage_mb: get_memory_usage(),
        uptime_seconds: get_uptime(),
        quantum_enabled: engine.quantum_enabled(),
        persistence_enabled: engine.persistence_enabled(),
    })
}
```

This architecture enables the quantum resonant search engine to operate efficiently across multiple modes while maintaining the mathematical rigor of the underlying quantum-inspired algorithms.

---

*For implementation details, see the individual module documentation in the source code.*